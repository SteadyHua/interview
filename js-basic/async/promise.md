# promise

## 如何解决异步回调地狱

1. 大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流 程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码，会导致坏 bug。
   我们需要一种更同步、更顺序、更阻塞的的方式来表达异步，就像我们的大脑一样。
2. 也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更 笨重、更难维护的代码，并且缺少足够的保护，其中的损害要直到你受到 bug 的影响才会 被发现。
   我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可 以复用，且没有重复代码的开销。

## Promise 简介

`Promise` 是一个对象，保存着未来将要结束的事件，她有两个特征:

1、对象的状态不受外部影响，`Promise` 对象代表一个异步操作，有三种状态，pending进行中，fulfilled已成功，rejected已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是promise名字的由来

2、一旦状态改变，就不会再变，`Promise`对象状态改变只有两种可能，从pending改到fulfilled或者从pending改到rejected，只要这两种情况发生，状态就凝固了，不会再改变，这个时候就称为定型resolved

## Promise 为什么以及如何用于解决控制反转信任问题

Promise 这种模式通过可信任的语义把回调作为参数传递，使得这种行为更可靠更合理。 通过把回调的控制反转反转回来，我们把控制权放在了一个可信任的系统(Promise)中， 这种系统的设计目的就是为了使异步编码更清晰。Promise 并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任 的中介机制。

- 调用回调过早;

  - 这个问题主要就是担心代码是否会引入类似 Zalgo 这样的副作用(参见第 2 章)。在这类问 题中，一个任务有时同步完成，有时异步完成，这可能会导致竞态条件。

    根据定义，Promise 就不必担心这种问题，因为即使是立即完成的 Promise(类似于 new Promise(function(resolve){ resolve(42); }))也无法被同步观察到。

    也就是说，对一个 Promise 调用 then(..) 的时候，即使这个 Promise 已经决议，提供给 then(..) 的回调也总会被异步调用(对此的更多讨论，请参见 1.5 节)。

- 调用回调过晚(或不被调用); 

  - 和前面一点类似，Promise 创建对象调用 resolve(..) 或 reject(..) 时，这个 Promise 的 then(..) 注册的观察回调就会被自动调度。可以确信，这些被调度的回调在下一个异步事 件点上一定会被触发(参见 1.5 节)。

- 回调未调用

  - 首先，没有任何东西(甚至 JavaScript 错误)能阻止 Promise 向你通知它的决议(如果它 决议了的话)。如果你对一个 Promise 注册了一个完成回调和一个拒绝回调，那么 Promise 在决议时总是会调用其中的一个。
  - 但是，如果 Promise 本身永远不被决议呢?即使这样，Promise 也提供了解决方案，其使用 了一种称为竞态的高级抽象机制:

- 调用回调次数过多;

  - Promise 的定义方式使得它只能被决议一次。如果出于某种 原因，Promise 创建代码试图调用 resolve(..) 或 reject(..) 多次，或者试图两者都调用， 那么这个 Promise 将只会接受第一次决议，并默默地忽略任何后续调用。
  - 由于 Promise 只能被决议一次，所以任何通过 then(..) 注册的(每个)回调就只会被调 用一次。

- 未能传递所需的环境和参数;

  - Promise 至多只能有一个决议值(完成或拒绝)。

    如果你没有用任何值显式决议，那么这个值就是 undefined，这是 JavaScript 常见的处理方 式。但不管这个值是什么，无论当前或未来，它都会被传给所有注册的(且适当的完成或 拒绝)回调。

- 吞掉可能出现的错误和异常。

  - 如果拒绝一个 Promise 并给出一个理由(也就是一个出错消息)，这个值就会被传给拒绝回调

## Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？

Promise 构造函数时同步执行的；then 方法是微任务，是异步执行。

看[事件循环](js-basic/event_loop.md)



## 实现一个 Promise

[看这里](https://github.com/forthealllight/blog/issues/4)

我简单总结一下，总的思路就是：

1. 阅读 [Promise/A+](https://promisesaplus.com/)规范，里面详细地定义了需要实现什么功能。不想看英文的可以[看这个](https://www.ituring.com.cn/article/66566)
2. 按照规范实现

## promise、generator、async/await

- promise

  - 优点：解决了回调地狱的问题
  - 缺点：无法取消 Promise ，错误需要通过回调函数来捕获

- generator

  - 生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤

- async/await

  - 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题

  - 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。